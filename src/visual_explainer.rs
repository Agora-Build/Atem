/// Visual Explainer — generate beautiful self-contained HTML pages
/// that explain a topic, piece of code, or agent output.
///
/// Uses the Anthropic API with a carefully crafted system prompt to
/// produce single-file HTML with embedded CSS/JS, CDN-loaded Mermaid,
/// Chart.js, and anime.js for diagrams, charts, and animations.
///
/// The page design matches Astation's dark theme and is meant to be
/// opened directly in a browser — no server required.
use anyhow::{anyhow, Result};
use serde::{Deserialize, Serialize};
use std::path::{Path, PathBuf};

const DEFAULT_API_URL: &str = "https://api.anthropic.com/v1/messages";
const DEFAULT_MODEL: &str = "claude-opus-4-6-20251101";

// ── System prompt ─────────────────────────────────────────────────────────

const SYSTEM_PROMPT: &str = r#"You are an expert technical visualizer. Your job is to generate a beautiful, self-contained HTML page that clearly explains the given topic.

REQUIREMENTS:
1. Output ONLY the HTML file — nothing before or after, no markdown fences.
2. The page must be entirely self-contained: all CSS inline, all JS inline or from CDN.
3. Use these CDN libraries where appropriate:
   - Mermaid.js  (https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js)     → architecture/flow/sequence diagrams
   - Chart.js    (https://cdn.jsdelivr.net/npm/chart.js)                           → data charts
   - anime.js    (https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js)     → subtle animations
   - Prism.js    (https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js + theme)→ code blocks
   - Inter font  (https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=JetBrains+Mono&display=swap)
4. Dark theme: background #0a0a0a, card background #111827, accent #6366f1 (indigo), text #e5e7eb.
5. Structure:
   - Hero section with animated title
   - Key concept cards (3-6 cards)
   - At least one Mermaid diagram OR Chart.js visualization
   - Code examples (if applicable, with Prism.js syntax highlighting)
   - Interactive elements where they add clarity
6. The <title> tag must contain the topic name.
7. Include a subtle footer: "Generated by Atem · Agora.Build"
8. Mobile-responsive layout (CSS grid/flexbox).
9. No external fonts that aren't from Google Fonts CDN — keep it self-contained.

STYLE GUIDE:
- Cards: border-radius 12px, subtle border (1px solid #1f2937), box-shadow
- Headings: gradient text (indigo to purple)
- Animations: entrance animations using anime.js on page load (translateY + opacity)
- Mermaid theme: dark
- Code blocks: dark background #1a1a2e with JetBrains Mono

Generate the COMPLETE, working HTML file now."#;

// ── API types ─────────────────────────────────────────────────────────────

#[derive(Serialize)]
struct ApiRequest {
    model: String,
    max_tokens: u32,
    system: String,
    messages: Vec<ApiMessage>,
}

#[derive(Serialize)]
struct ApiMessage {
    role: String,
    content: String,
}

#[derive(Deserialize)]
struct ApiResponse {
    content: Vec<ContentBlock>,
}

#[derive(Deserialize)]
struct ContentBlock {
    text: Option<String>,
}

// ── VisualExplainer ───────────────────────────────────────────────────────

pub struct VisualExplainer {
    api_key: String,
    api_url: String,
    model: String,
    http: reqwest::Client,
}

impl VisualExplainer {
    /// Create a new explainer.  Reads `ANTHROPIC_API_KEY` from the environment.
    pub fn new() -> Result<Self> {
        let api_key = std::env::var("ANTHROPIC_API_KEY").map_err(|_| {
            anyhow!("ANTHROPIC_API_KEY not set. Set it to use the Visual Explainer.")
        })?;
        let api_url = std::env::var("ATEM_AI_API_URL")
            .unwrap_or_else(|_| DEFAULT_API_URL.to_string());
        let model = std::env::var("ATEM_EXPLAINER_MODEL")
            .or_else(|_| std::env::var("ATEM_AI_MODEL"))
            .unwrap_or_else(|_| DEFAULT_MODEL.to_string());

        Ok(Self {
            api_key,
            api_url,
            model,
            http: reqwest::Client::new(),
        })
    }

    /// Generate a self-contained HTML explanation for `topic`.
    ///
    /// `context` is optional extra content (code, docs, agent output) that
    /// will be prepended to the user message to ground the explanation.
    pub async fn generate(&self, topic: &str, context: Option<&str>) -> Result<String> {
        let user_message = if let Some(ctx) = context {
            format!(
                "Topic: {}\n\nAdditional context:\n```\n{}\n```\n\nGenerate the HTML page.",
                topic, ctx
            )
        } else {
            format!("Topic: {}\n\nGenerate the HTML page.", topic)
        };

        let request = ApiRequest {
            model: self.model.clone(),
            max_tokens: 8192,
            system: SYSTEM_PROMPT.to_string(),
            messages: vec![ApiMessage {
                role: "user".to_string(),
                content: user_message,
            }],
        };

        let response = self
            .http
            .post(&self.api_url)
            .header("x-api-key", &self.api_key)
            .header("anthropic-version", "2023-06-01")
            .header("content-type", "application/json")
            .json(&request)
            .send()
            .await
            .map_err(|e| anyhow!("Visual Explainer API request failed: {e}"))?;

        if !response.status().is_success() {
            let status = response.status();
            let body = response.text().await.unwrap_or_default();
            return Err(anyhow!("Visual Explainer API returned {status}: {body}"));
        }

        let api_response: ApiResponse = response
            .json()
            .await
            .map_err(|e| anyhow!("Failed to parse API response: {e}"))?;

        let raw = api_response
            .content
            .first()
            .and_then(|b| b.text.as_deref())
            .ok_or_else(|| anyhow!("Empty response from Visual Explainer API"))?;

        Ok(strip_html_fence(raw))
    }

    /// Save HTML to a temp file.  Returns the file path.
    pub fn save_to_temp(html: &str) -> Result<PathBuf> {
        let dir = std::env::temp_dir().join("atem-explainer");
        std::fs::create_dir_all(&dir)?;

        let title = extract_title(html).unwrap_or_else(|| "explainer".to_string());
        let slug = slugify(&title);
        let path = dir.join(format!("{slug}.html"));

        std::fs::write(&path, html)?;
        Ok(path)
    }

    /// Open an HTML file in the system's default browser.
    pub fn open_in_browser(path: &Path) -> Result<()> {
        let url = format!("file://{}", path.display());

        #[cfg(target_os = "macos")]
        std::process::Command::new("open").arg(&url).spawn()?;

        #[cfg(target_os = "linux")]
        std::process::Command::new("xdg-open").arg(&url).spawn()?;

        #[cfg(target_os = "windows")]
        std::process::Command::new("cmd")
            .args(["/c", "start", &url])
            .spawn()?;

        Ok(())
    }
}

// ── Pure helper functions (testable) ─────────────────────────────────────

/// Extract the text content of the `<title>` tag from an HTML string.
pub fn extract_title(html: &str) -> Option<String> {
    let lower = html.to_lowercase();
    let start = lower.find("<title>")? + "<title>".len();
    let end = lower[start..].find("</title>")? + start;
    let title = html[start..end].trim().to_string();
    if title.is_empty() { None } else { Some(title) }
}

/// Check that an HTML page looks self-contained (has `<html>` and `<body>`).
pub fn is_valid_html(html: &str) -> bool {
    let lower = html.to_lowercase();
    lower.contains("<html") && lower.contains("<body")
}

/// Check that the generated page includes at least one of our expected CDN libs.
pub fn has_cdns(html: &str) -> bool {
    html.contains("cdn.jsdelivr.net") || html.contains("fonts.googleapis.com")
}

/// Strip markdown code fences (```html ... ```) if the API wrapped the output.
pub fn strip_html_fence(text: &str) -> String {
    let text = text.trim();
    // ```html\n...\n```
    if let Some(inner) = text
        .strip_prefix("```html")
        .or_else(|| text.strip_prefix("```HTML"))
        .or_else(|| text.strip_prefix("```"))
    {
        if let Some(end) = inner.rfind("```") {
            return inner[..end].trim().to_string();
        }
        return inner.trim().to_string();
    }
    text.to_string()
}

/// Convert a title to a URL/filename-safe slug.
pub fn slugify(title: &str) -> String {
    title
        .to_lowercase()
        .chars()
        .map(|c| if c.is_alphanumeric() { c } else { '-' })
        .collect::<String>()
        .split('-')
        .filter(|s| !s.is_empty())
        .collect::<Vec<_>>()
        .join("-")
}

/// Check whether the HTML contains a Mermaid diagram block.
pub fn has_mermaid(html: &str) -> bool {
    html.contains("mermaid") || html.contains("class=\"mermaid\"")
}

// ── Tests ─────────────────────────────────────────────────────────────────

#[cfg(test)]
mod tests {
    use super::*;

    // ── extract_title ─────────────────────────────────────────────────────

    #[test]
    fn test_extract_title_basic() {
        let html = "<html><head><title>ACP Protocol</title></head><body></body></html>";
        assert_eq!(extract_title(html).as_deref(), Some("ACP Protocol"));
    }

    #[test]
    fn test_extract_title_case_insensitive_tag() {
        let html = "<HTML><HEAD><TITLE>My Page</TITLE></HEAD><BODY></BODY></HTML>";
        assert_eq!(extract_title(html).as_deref(), Some("My Page"));
    }

    #[test]
    fn test_extract_title_with_whitespace() {
        let html = "<title>  Spaced Title  </title>";
        assert_eq!(extract_title(html).as_deref(), Some("Spaced Title"));
    }

    #[test]
    fn test_extract_title_missing() {
        let html = "<html><head></head><body></body></html>";
        assert!(extract_title(html).is_none());
    }

    #[test]
    fn test_extract_title_empty_tag() {
        let html = "<title></title>";
        assert!(extract_title(html).is_none());
    }

    // ── is_valid_html ─────────────────────────────────────────────────────

    #[test]
    fn test_is_valid_html_true() {
        let html = "<!DOCTYPE html><html><head></head><body><p>hi</p></body></html>";
        assert!(is_valid_html(html));
    }

    #[test]
    fn test_is_valid_html_partial_false() {
        let html = "<p>just a paragraph</p>";
        assert!(!is_valid_html(html));
    }

    #[test]
    fn test_is_valid_html_case_insensitive() {
        let html = "<HTML><BODY></BODY></HTML>";
        assert!(is_valid_html(html));
    }

    // ── has_cdns ──────────────────────────────────────────────────────────

    #[test]
    fn test_has_cdns_with_jsdelivr() {
        let html = r#"<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>"#;
        assert!(has_cdns(html));
    }

    #[test]
    fn test_has_cdns_with_google_fonts() {
        let html = r#"<link href="https://fonts.googleapis.com/css2?family=Inter">"#;
        assert!(has_cdns(html));
    }

    #[test]
    fn test_has_cdns_false() {
        let html = "<html><body>no libs</body></html>";
        assert!(!has_cdns(html));
    }

    // ── strip_html_fence ──────────────────────────────────────────────────

    #[test]
    fn test_strip_fence_html_prefix() {
        let text = "```html\n<!DOCTYPE html><html></html>\n```";
        let result = strip_html_fence(text);
        assert_eq!(result, "<!DOCTYPE html><html></html>");
    }

    #[test]
    fn test_strip_fence_plain_prefix() {
        let text = "```\n<html></html>\n```";
        let result = strip_html_fence(text);
        assert_eq!(result, "<html></html>");
    }

    #[test]
    fn test_strip_fence_no_fence() {
        let text = "<!DOCTYPE html><html></html>";
        let result = strip_html_fence(text);
        assert_eq!(result, text);
    }

    #[test]
    fn test_strip_fence_uppercase() {
        let text = "```HTML\n<html></html>\n```";
        let result = strip_html_fence(text);
        assert_eq!(result, "<html></html>");
    }

    #[test]
    fn test_strip_fence_trims_whitespace() {
        let text = "  ```html\n  <html></html>\n  ```  ";
        let result = strip_html_fence(text);
        assert_eq!(result, "<html></html>");
    }

    // ── slugify ───────────────────────────────────────────────────────────

    #[test]
    fn test_slugify_simple() {
        assert_eq!(slugify("ACP Protocol"), "acp-protocol");
    }

    #[test]
    fn test_slugify_special_chars() {
        assert_eq!(slugify("JSON-RPC 2.0 Overview!"), "json-rpc-2-0-overview");
    }

    #[test]
    fn test_slugify_multiple_spaces() {
        assert_eq!(slugify("hello   world"), "hello-world");
    }

    #[test]
    fn test_slugify_empty() {
        assert_eq!(slugify(""), "");
    }

    #[test]
    fn test_slugify_numbers() {
        assert_eq!(slugify("Stage 3"), "stage-3");
    }

    // ── has_mermaid ───────────────────────────────────────────────────────

    #[test]
    fn test_has_mermaid_true() {
        let html = r#"<div class="mermaid">graph TD; A-->B;</div>"#;
        assert!(has_mermaid(html));
    }

    #[test]
    fn test_has_mermaid_via_script() {
        let html = r#"<script src="mermaid.min.js"></script>"#;
        assert!(has_mermaid(html));
    }

    #[test]
    fn test_has_mermaid_false() {
        let html = "<html><body><p>no diagrams here</p></body></html>";
        assert!(!has_mermaid(html));
    }

    // ── VisualExplainer::new ──────────────────────────────────────────────

    #[test]
    fn test_new_requires_api_key() {
        let prev = std::env::var("ANTHROPIC_API_KEY").ok();
        unsafe { std::env::remove_var("ANTHROPIC_API_KEY") };
        let result = VisualExplainer::new();
        assert!(result.is_err());
        if let Some(key) = prev {
            unsafe { std::env::set_var("ANTHROPIC_API_KEY", key) };
        }
    }

    #[test]
    fn test_new_with_api_key() {
        unsafe { std::env::set_var("ANTHROPIC_API_KEY", "test-key-123") };
        let result = VisualExplainer::new();
        assert!(result.is_ok());
        unsafe { std::env::remove_var("ANTHROPIC_API_KEY") };
    }

    // ── save_to_temp ──────────────────────────────────────────────────────

    #[test]
    fn test_save_to_temp_creates_file() {
        let html = "<html><head><title>Test Page</title></head><body>hello</body></html>";
        let path = VisualExplainer::save_to_temp(html).unwrap();
        assert!(path.exists());
        assert_eq!(std::fs::read_to_string(&path).unwrap(), html);
        let _ = std::fs::remove_file(&path);
    }

    #[test]
    fn test_save_to_temp_uses_slug_in_filename() {
        let html = "<html><head><title>ACP Protocol</title></head><body></body></html>";
        let path = VisualExplainer::save_to_temp(html).unwrap();
        assert!(path.file_name().unwrap().to_str().unwrap().contains("acp-protocol"));
        let _ = std::fs::remove_file(&path);
    }

    #[test]
    fn test_save_to_temp_falls_back_for_missing_title() {
        let html = "<html><body>no title</body></html>";
        let path = VisualExplainer::save_to_temp(html).unwrap();
        assert!(path.file_name().unwrap().to_str().unwrap().contains("explainer"));
        let _ = std::fs::remove_file(&path);
    }

    #[test]
    fn test_save_to_temp_is_html_extension() {
        let html = "<html><head><title>Test</title></head><body></body></html>";
        let path = VisualExplainer::save_to_temp(html).unwrap();
        assert_eq!(path.extension().unwrap(), "html");
        let _ = std::fs::remove_file(&path);
    }
}
